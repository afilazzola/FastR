---
output: 
  html_document:
    theme: sandstone
    toc: yes
    toc_depth: 3
    toc_float: yes
---
# Vectorization

![](MustGoFaster.jpg)

### To vectorize or not to vectorize

```{r warning=F, message=F}
### Needed libraries
library(microbenchmark)

```

I've often seen the argument that you should always vectorize in R whenever you possible can. There certainly is some merit to using vectorization and in almost all cases, vectorized code will perform equally or better than unvectorized code. However, there is a learning curve and a bit of extra thought that is necessary to transform code into the necessary vectorized format. Depending on how much time is invested, that can result in net-zero or negative effect on your productivity. To help you make the decision whether to invest time in optimizing your code through vectorization, I think it makes sense to explain what vectorization means, the pros, and the cons. 

As far as I'm aware, there is only one con so let's just get it out of the way. Vectorization is not intuitive. It requires a bit of abstract thinking to implement. Maybe if you did it all time, vectorization will come naturally to you, but new and complex tasks requires some time where you are blankly staring at your script thinking what to do. Time that could be spent throwing a `for` loop infront of your code and having it already runing. What complicates this further is that easier instances where vectorization would be particularly applicable, base R and new packages have already written wrappers that take away the advantage. 

Let's look at an example - You need the sum for a dataset of 100 columns and 10 rows. Three ways you can execute this operation are 1. using a for loop, 2. using the apply family, 3. using the `colSums` function in base R. 

### The speed of vectorization
```{r eval=F}
### create dataset
dataset <- rnorm(1000, 10, 2) %>% matrix(. , nrow=10, ncol=100) %>% data.frame()

### Loop
microbenchmark({
  
sums <- c()
for(i in 1:100){
  t <- sum(dataset[,i])
  sums <- c(sums,t)
}

}, unit="ms")

### Apply
microbenchmark({

apply(dataset, 2, sum)
  
}, unit="ms")


### ColSums
microbenchmark({

colSums(dataset)
  
}, unit="ms")
```

In this example, we can find that the vectorized apply family executes the function on average 5.5 times faster. The colsums wrapper is tied with the apply family, mostly because it uses the same underlying algorithms. Thus, you could probably last a long time in R just using wrapper functions and for loops. But, this is a workhop on making this go faster and getting a 5.5x boost sounds pretty appealing when your functions take hours to run. Let's take a look at why vectorization works

### What is vectorization? 

Vectorization means executing a function across a vector of elements. What this means in the context of R and your functions is that you giving more flexibility to your computer to run the operation. To understand what that means, we need to first understand how R works as a programming lanuage. Big thanks to Dr. Noam Ross for an [excellent explanation](https://www.noamross.net/archives/2014-04-16-vectorization-in-r-why/)

R is a high-level interpreted language, which is one of the reasons its so appealing for scientists without a computer science degree. The extra leg work of assinging floating numbers, strings, pointers in the memory, etc, all are handled behind the scenes. A simple task of renaming an object from 25.2 to "foo" can occur within two lines of code. 

```{r eval=F}
x <- 25.2
x <- "foo"
```

This same operation in a different language like C would require something closer to 10 lines of code. Additionally, C is a compiled language where the entire program is organized and optimized to be run in binary machine code, rather than the line-by-line execution of R. As a result, C has the potential for greater efficiencies that are unavailable to R. All is not lost though because many R functions are written in C, C++, or Fortran. For example, `lme4` a popular package for mixed-effect models is written mostly in C++. The `apply` family is one of those examples and by using it, the bulk of the operations are being executed in C. By trusting your computer to execute the operations in the most efficient way possible, operations tend to run faster. 

### Other benefits of vectorization besides speed?

There are two other reasons one might perfer to vectorize besides the speed gains. The first is that the code is often shorter. In the previous example, the for loop required five lines of code that included specifying an empty vector to fill, the `for` loop specification, the operation to be conducted iteratively, and finally appending the output. By contrast, the apply family executes everything within a single line which looks more elegant. 

```{r eval=F}
## For loop
sums <- c() ## specify empty vector
for(i in 1:100){
  t <- sum(dataset[,i]) ## conduct iterated operation
  sums <- c(sums,t) ## append
}


### Apply
apply(dataset, 2, sum) ## dataframe, by columns, function

```

The second benefit is that `for` loops keep outputs and objects in the environment. This can be bad practice by filling up your memory or potentially causing a conflict down the road. For example, after the above `for` loop is executed `i = 100`. That means a future operation where `i` is called, there is the risk its value will be 100 (such as another loop). 


### The `Apply` Family

There are multiple versions of apply (e.g. apply, sapply, vapply) including parallel versions (e.g. parLapply). Today we will look at `apply` and `lapply`. We will also look at executing these operations in `tidyverse`. 

Apply works across dataframes to execute a function. It will either run across rows (MARGIN=1 default) or columns (MARGIN=2). The function can be inherent in R, from a package or user specified. Let's look at some examples.

```{r eval=F}
## Sum across rows
apply(dataset, 1, sum)

## Sum across columns
apply(dataset, 2, sum)

## Mean across columns
apply(dataset, 2, mean)

## User specifed functions
se <- function(x) {sd(x)/sqrt(length(x))} ## standard error
apply(dataset, 2, se) 

zScore <- function(x) { (x - mean(x) / sd(x))}
apply(dataset, 2, zScore) 

```

The lapply family works very similar to the `for` loop but outputs data as a list. These can usually simplified using a `do.call` function. While this operation is very inefficient, even compared to `for` loops, there are instances where this is considerably faster, such as reading in 100 CSVs and combining into a single dataframe. 

```{r eval=F}

## using lapply for sum across columns
sumOut <- lapply(1:100, function(i){
    sum(dataset[,i]) ## conduct iterated operation
})
do.call(c, sumOut)



```

# Tidyverse

Where I think vectorization gets the most power is through combination with `tidyverse`. This allows for rapid computations of subsets of the data that would considerably more lines of code and slower using `for` loops.

*What is tidyverse?*
[The tidyverse](https://www.tidyverse.org/) "is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures." The tidyverse contains some extremely useful packages such as

- <code>[**ggplot2**](https://ggplot2.tidyverse.org/)</code>, which lets you make fantastic graphics;
- <code>[**tidyr**](https://tidyr.tidyverse.org/)</code>, which helps you "tidy" (clean) up your data; and
- <code>[**dplyr**](https://dplyr.tidyverse.org/)</code>, which lets you manipulate your data, like you would with pliers (hence d-*plyr*).
<br/>


### Install and load packages 
```{r load-packages,  message=FALSE, warning=FALSE}
library(here) # Look where your folder begins.
library(magrittr)
library(dplyr)
library(tidyr)
library(broom)
```

### Save this built-in dataset as a dataframe
The "The Effect of Vitamin C on Tooth Growth in Guinea Pigs" dataset contains data from an experiment wherein 60 guinea pigs were given vitamin C either as pure vitamin C (VC) or orange juice (OJ) (column "supp") in doses of 0.5, 1, or 2 mg/day (column "dose"). The researchers recorded the growth of their teeth (column "len").
```{r}
teeth <- ToothGrowth
```

#### Today we will work through examples of these tidyverse functions:

- **<code>mutate()</code>**
- **<code>group_by()</code>**
- **<code>summarize()</code>**
- **<code>filter()</code>**
- **<code>select()</code>**

#### Then we'll introduce some functions from the **<code>broom</code>** package that are especially useful for working with linear models such as 

- **<code>tidy()</code>**
- **<code>augment()</code>**
- **<code>glance()</code>**

#### Prequel: **<code>magrittr</code>**'s pipes
A fantastic tool that is worth getting to know is the **<code>magrittr</code>** package's collection of operators called *pipes*. As stated on their [webpage](https://magrittr.tidyverse.org/),

> "The **<code>magrittr</code>** package offers a set of operators which make your code more readable by:

> - structuring sequences of data operations left-to-right (as opposed to from the inside and out),
> - avoiding nested function calls,
> - minimizing the need for local variables and function definitions, and
> - making it easy to add steps anywhere in the sequence of operations."  
  
##### We'll frequently set up our code like this:

<code>new_object <- old_object %>% function()</code>


##### If you'd rather overwrite your original object, you can use either of these setups:

<code>old_object <- old_object %>% function()</code>

<code>old_object %<>% function()</code> *(notice that the pipe has two arrows inside it now)* <br/><br/>

***

### **<code>mutate()</code>**
The `mutate()` function lets us create new columns based on existing columns. In this example, we'll create a new column that takes the "len" data- guinea pig tooth length measured in mm- and divide it by 100 to create a similar column with cm as the unit of length.

The `.` after mutate( refers to how we're performing the <code>mutate()</code> function on the object already named after the assignment arrow (the teeth object).
```{r}
teeth <- teeth %>%
  dplyr::mutate(.,
                len_cm = len / 100)

head(teeth)
```

We can also mutate multiple columns at once. Let's add a new column that calculates the mean tooth length for all guinea pigs:
```{r}
teeth <- teeth %>%
  dplyr::mutate(.,
                len_cm = len / 100,
                mean_len = mean(len))

head(teeth)
```

<br/>

### **`group_by()`**
So now we know the mean tooth length for all guinea pigs, but that's not very helpful. It'd be more informative to know the mean tooth length for specific groups of guinea pigs- based on the doses of vitamin C adminstered and the method of administration.
First, let's group the subjects by the method of administration (supp) to find the mean tooth length per group (VC or OJ):
```{r}
teeth_2 <- teeth %>%
  dplyr::group_by(supp) %>%
  dplyr::mutate(.,
         mean_len = mean(len))

head(as.data.frame(teeth_2), 60)
```


Now let's incorporate dosage (dose) as another grouping so that the subjects are grouped by both supp *and* dose:
```{r}
teeth_2 <- teeth %>%
  dplyr::group_by(supp, dose) %>%
  dplyr::mutate(.,
         mean_len = mean(len))

head(as.data.frame(teeth_2), 60)
```

That's more like it!

However, there's a better way to organize this data...

<br/>

### **`summarize()`**
If you don't need to keep the individual subjects' tooth length data, then it makes sense to use <code>summarize()</code> to condense our summarized data into fewer rows. Our output file will have one row for each combination of supp x dose.
```{r}
teeth_3 <- teeth %>%
  dplyr::group_by(supp, dose) %>%
  dplyr::summarize(mean_len = mean(len))

head(teeth_3)
```

You can even summarize multiple times, such as if you wanted to first get mean values per supp x dose group and then average *those* values to get mean length per supp group.
```{r}
teeth_4 <- teeth %>%
  dplyr::group_by(supp, dose) %>%
  dplyr::summarize(mean_len = mean(len)) %>%
  dplyr::group_by(supp) %>%
  dplyr::summarize(mean_len = mean(mean_len))

head(teeth_4)
```

What if you just want to summarize all the rows of your dataset? Then you can use <code>summarize()</code> in conjunction with the <code>across()</code> "helper" function.


Let's calculate the mean values for dose and len_cm. To do so, you'd set up your code like this. Be sure you're not selecting any non-numeric columns, like supp.
```{r }
teeth_5 <- teeth %>%
  dplyr::summarize(across(dose:len_cm, mean))

teeth_5
```


You can even summarize multiple variables in multiple ways, like in this example, where we're calculating both mean, maximum, and minimum values for dose and length. In the set of parentheses determining which calculations to perform (mean, max, min), be sure to put the suffix you want to append to the column name first (e.g. mean, maximum, minimum), then the = sign, then the R-recognized calculation name (mean, max, min).
```{r}
teeth_6 <- teeth %>%
  dplyr::summarize(across(c(len, dose),
                          c(mean = mean,
                            maximum = max,
                            minimum = min))) %T>%
  print()
```
*You'll also notice that I added a special pipe- **%T>%**- plus the <code>print()</code> function at the end of the command. This tells R to perform the functions after the special pipe but to not associate those functions with the object being created (teeth_6). This pipe is very useful when creating plots, for instance.*


Let's imagine that you only want to focus on the guinea pigs given orange juice. How would you get rid of the other rows?

<br/>

### **<code>filter()</code>**
The <code>filter()</code> function lets you filter out the rows you don't want. Here we've added a line of code to keep only the rows where the guinea pig was given vitamin C as orange juice (OJ), not as pure vitamin C.
```{r}
teeth_7 <- teeth %>%
  dplyr::filter(supp == "OJ")

head(teeth_7)
```

<br/>

### **<code>select()</code>**
Similarly, the <code>select()</code> function lets you filter out the *columns* you don't want. Our new dataframe only includes the first three columns: from len to dose. Both of these commands accomplishes the same goal, whether you name the columns by their names or index position.
```{r}
teeth_8 <- teeth %>%
  dplyr::select(len:dose)

head(teeth_8)


teeth_8 <- teeth %>%
  dplyr::select(1:3)

head(teeth_8)
```

<br/>

***

### Helpful Functions for Linear Models

Let's load a new built-in dataset: warpbreaks. This dataset contains data regarding the number of breaks in yarn accumulated while weaving based on the yarn's wool type and amount of tension.
```{r}
yarn <- warpbreaks
```

We're going to set up some linear models- one for each type of wool- and then use three functions from the <code>broom</code> package to summarize important information about the models which will be generated in a format that makes it simple to compare and plot models.

As stated in the [**<code>broom</code>** overview page](https://broom.tidymodels.org/), here is the role of each function:

#### **<code>tidy()</code>**: 
*"Summarizes information about model components"*

#### **<code>augment()</code>**
*"Reports information about the entire model"*

#### **<code>glance()</code>**
*"Adds informations about observations to a dataset"*


<br/>

#### Set up individual models The long way
 
```{r}
mod1 <- lm(breaks ~ tension,
           yarn %>% filter(wool == "A"))

mod2 <- lm(breaks ~ tension,
           yarn %>% filter(wool == "B"))
```

<br/>

### **<code>tidy()</code>**
```{r}
broom::tidy(mod1)
# broom::tidy(mod2)
```

<br/>

### **<code>augment()</code>**
```{r}
broom::augment(mod1)
# broom::augment(mod2)
```

<br/>

### **<code>glance()</code>**
```{r}
broom::glance(mod1)
# broom::glance(mod2)
```

<br/>

### The *fastR* way to conduct linear models:
Notice that we are using the <code>group_by</code> function perform the same command on each wool type but in the same chunk of code.

<br/>

### **<code>tidy()</code>**
```{r}
# tidy
mod_all.tidy <- yarn %>%
  group_by(wool) %>%
  do(fit = broom::tidy(lm(breaks ~ tension,
              data = .))) %>%
  unnest(fit) %T>%
  print()
```

<br/>

### **<code>augment()</code>**
```{r}
mod_all.augment <- yarn %>%
  group_by(wool) %>%
  do(fit = broom::augment(lm(breaks ~ tension,
              data = .))) %>%
  unnest(fit) %T>%
  print()
```

<br/>

### **<code>glance()</code>**
```{r}
mod_all.glance <- yarn %>%
  group_by(wool) %>%
  do(fit = broom::glance(lm(breaks ~ tension,
              data = .))) %>%
  unnest(fit) %T>%
  print()
```




#### Next Module

<style>
.btn {
  border: none;
  background-color: inherit;
  padding: 14px 28px;
  font-size: 16px;
  cursor: pointer;
  display: inline-block;
  color: orange;
}
.btn:hover {background: #5DADE2;}
</style>


<a class="btn" href="https://afilazzola.github.io/FastR/"> Home </a>
<a class="btn" href="https://afilazzola.github.io/FastR/forloops/forLoops.html"> For Loops </a>