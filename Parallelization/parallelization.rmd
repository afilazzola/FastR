---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Parallelization
  
![](parallelProcess.png)
  
### Concept and terminology

Parallel computing is not unique to R and is used frequently by many programming languages and natively in your computer environment. With the widespread option of multiple core processors, parallel programming is becoming increasingly more common. At its most basic, parallel computing is **running multiple iterations of a process simultaenously (i.e., split) across multiple cores**. Essentially envision having two computers beside on another executing the task at hand. This analogy is particularly relevant because it helps frame conceptually what is going on with the computer and some of the draw backs or limitations of parallelization. 

In R, parallel computing can loosely categorized into two groups. 

1) User-specified parallel actions
2) Library-specified parallel execution
  
In the first instance, the user is doing most of the parallel work *manually*. This means identifying the processors to use, what process is to be run iteratively, how that process is to be split across cores, etc. There is some range in how specific a user choose options, but in this option, most elements need to be spelled out. Popular examples include `foreach`, `ddply`, and `parLapply`. 

In the second instance, a package has been written that allows the user to simply specify the number of cores to be used. The backend of how those cores are used has already been designed into the function either in `R` or another language (commonly C++). There are many examples, but one commonly used is `pdredge`. 

Before we dig into when to code in parallel and how to conduct it, we first need to go through some basic terminology. Unfortunately, termninology is not consistent in the parallel computing world. I am not entirely sure why this is the case, but I imagine it has something to do with different system architechs and programming languages developing their own nomenclature. 

### Theory

The concept of a `for` loop is something pervsaive across many programming languages. Packages and vectorization are generally optimized versions `for` loops that are executed in a more efficient programming language such as C++. However, R still allows utilization of `for` loops. 

When I was first getting started trying to iterate through many tasks, I found `for` loops relatively inutitive compared to some other methods such as vectorization. I believe the greater understandability has to do with the structure. A `for` loop, similar to a function, is a task completed normally but then with one variable that changes, which allows the iterations. Let's take a look at an example of what that might look like getting the correlation between variables among some groups. 

We are going to use the [penguin dataset by Allison Horst](https://allisonhorst.github.io/palmerpenguins/) as an alternate to the [controversial iris dataset](https://www.garrickadenbuie.com/blog/lets-move-on-from-iris/). 

```{r warning=F, message=F}
library(palmerpenguins)
penguins <- penguins[!is.na(penguins$body_mass_g),]
penguins <- data.frame(penguins) ## drop NAs and convert to  data.frame
str(penguins)


### separate linear models for each species
adelie <- subset(penguins, species=="Adelie")
corAde <- cor(adelie$bill_length_mm, adelie$bill_depth_mm, use="complete.obs")
chinstrap <- subset(penguins, species=="Chinstrap")
corchin <- cor(chinstrap$bill_length_mm, chinstrap$bill_depth_mm, use="complete.obs")
gentoo <- subset(penguins, species=="Gentoo")
corGen <- cor(gentoo$bill_length_mm, gentoo$bill_depth_mm, use="complete.obs")
penguinDF <- data.frame(species=c("Adelie","Chinstrap","Gentoo"), 
                        corValue =c(corAde,corchin,corGen) )

```

The above approach has a few issues with it. Besides being labour intensive, the copy-paste of multiple lines runs of the risk of an error appearing. The person analyzing this data might miss an argument, such as the `use` arguement, or might misspell one of the target species they are analyzing. Without an error message produced by R, there is no way to determine that an error was made along the way. Most importantly, this strategy does not scale easily. For three species, it is annoying, for 1000 species it is impractical. 

We can iterate through these same operations using a `for` loop with less code and less potential of errors. First let's take a look at the basics of what the `for` loop syntax is. At the beginning of the loop you specify the character to iterate through and what values you want them to be assigned. Here list the numbers 1 through 5 by printing the iterating value of i. 

```{r}
for(i in 1:5){
  print(i)
}

```

We can extend this logic to our previous example of subsetting and correlations. Copying down the same syntax from the correlation example, we create a generic dataframe that will be written over each iteration. The important difference here is that as the loop works it will continue to write over objects. We will need to specify a value that comes out so that we get a value for each iteration. 

```{r}

## list species
speciesNames <- c("Adelie","Chinstrap","Gentoo")

## Empty vector to fill
outCor <- c()

for(i in 1:3){
tempPenguin <- subset(penguins, species==speciesNames[i]) ## subset species by that iteration
corVal <- cor(tempPenguin$bill_length_mm, tempPenguin$bill_depth_mm, use="complete.obs") ##conduct correlation
outCor <- c(outCor,corVal) ## join empty vector with new cor value
}
outCor

```

While it is common to use a number to iterate through, you can also use characters or factors like we have in this example. There are some instances where this would be preferable. 

```{r}

## Empty vector to fill
outCor <- c()

for(i in c("Adelie","Chinstrap","Gentoo")){
tempPenguin <- subset(penguins, species== i ) ## subset species by that iteration
corVal <- cor(tempPenguin$bill_length_mm, tempPenguin$bill_depth_mm, use="complete.obs") ##conduct correlation
outCor <- c(outCor,corVal) ## join empty vector with new cor value
}
outCor

```

Let's take a look at another example but with linear models where we extract the co-efficients from those models.

```{r}
## Empty data.frame to fill
coefout <- data.frame()

for(i in c("Adelie","Chinstrap","Gentoo")){
model <- lm(flipper_length_mm ~ body_mass_g, data= penguins, species == i )
dfTemp <- data.frame(species= i, 
                      coefficient = coef(model)[2],
                      intercept = coef(model)[2])
coefout <- rbind(coefout,dfTemp)
}
coefout
```

It is also possible to nest `for` loops within one another. Nested for loops are more common and more efficient in other programming languages. However, they are still possible in R and have their utility. We can repeat the above example using another subset. 

```{r}
## Empty data.frame to fill
coefout <- data.frame()

for(i in c("Adelie","Chinstrap","Gentoo")){
  for(j in 2007:2009){
    
model <- lm(flipper_length_mm ~ body_mass_g, data= penguins, species == i & year == j )
dfTemp <- data.frame(species= i, 
                     year = j,
                      coefficient = coef(model)[2],
                      intercept = coef(model)[2])
coefout <- rbind(coefout,dfTemp)
  }
}
coefout
```

Here the sky is the limit. Really, anything you can do once, can be set to run infinitely using for loops. The vectors supplied to `i` or `j` can be hundreds, thousands, or longer. You can have multiple nestings within one another. Our examples here use dataframes and vectors, but all this could be repeated with rasters, plots, graphics, or any object loaded into R. There are many, many options. This is where I believe the `for` loop has its greatest strength. Using this formula, anything that can be loaded into R can be replicated this way. 

There is a formula that I try and follow. The formula is as follows:

1. Create a object to receive exports from the loop.
2. Specify a vector to change (either a number to iterate through or specific elements)
3. Run the operation (remember most objects in this section will be constantly written over each iteration)
4. Export needed elements to external object


Let's try that formula with some plots
```{r}

par(mfrow=c(3,3))
for(i in 1:3){
  for(j in 1:3){
  tempdf <- rnorm(1000, mean= i, sd = j )
  hist(tempdf, main=paste0("Mean = ",i," & SD = ",j))
  }
}


```

Next, we are going to look at troubleshooting some problems in `for` loops. The most common error that will arise is that one iteration will break. This can arise for a number of reasons, but typically involves an error message in a function that prevents completion of the loop, such as the example below. 


```{r eval=F}

par(mfrow=c(1,3))
for(i in 2006:2008){
  m1 <- lm(bill_length_mm ~ body_mass_g, data=penguins, year==i)
  hist(residuals(m1))
}

```

Troubleshooting is the next logical step. However, there can often be times you want the entire loop to complete because either a) the errors can be skipped, or b) all errors need to be identified to properly troubleshoot. We will explore `next` for *a* and `TryCatch` for *b*. There is also the `break` function for those looking to exit the loop specifically at the error to try and resolve it. 

![](nextFlow.png)
![](breakFlow.jpg)
Flowcharts curtosy of [www.datamentor.io](www.datamentor.io)

```{r}
## Loop without conditional next
valOut <- c() ## empty vector
for (i in 0:5){
  tempVal <- log(i) 
  valOut <- c(valOut,tempVal)
}
valOut ## output


## Adding in next statement
valOut <- c()
for (i in 0:5){
  tempVal <- log(i) 
  if(is.infinite(tempVal)) { ## test expression of the loop
  next ## skip remainder of loop if test is true
  }
  valOut <- c(valOut,tempVal)
}
valOut
```

While `next` is good for pushing through on conditions, it is less helpful when it comes to errors. That is where `tryCatch` comes in. `tryCatch` will allow the loop to continue through and has the helpful option of outputting an error message. Let's apply it to the above example with the linear model. 

```{r}

par(mfrow=c(1,3))
for(i in 2006:2008){
  tryCatch({ ## wrap the entire loop in a Try catch
  m1 <- lm(bill_length_mm ~ body_mass_g, data=penguins, year==i)
  hist(residuals(m1))
  }, error = function(e) print(i)) ## specify what occurs with an error messagge
}

```

Here we specify which iteration of the loop causes an error to occupy. Importantly, the iterations that are without error are still produced. These are all effective at trying to resolve bugs and troubleshoot errors in complex loops or massive iterations. There is also no limit to the applicatino of `tryCatch`. Multiple `tryCatch` conditions can be implemement at different stages of particularly long loops. This allows for the identification of errors at different points. 

While we have showed the application of `tryCatch` for loops, its has an equally important role in functions. Using the same syntax and error identification, one can use `tryCatch` to develop functions that provide useful error messages. 

