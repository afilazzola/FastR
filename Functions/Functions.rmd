---
title: "Functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

![](functions.jpg)

### Introduction

Writing functions is a fundamental component of programming and therefore scares many people. However! Functions can be easier than you’d think. For example, think of what your perfect bar plot looks like. How much time do you spend making your bar plots look like that? Wouldn’t it be great if the very first time you plotted a barplot it looked exactly the way you wanted it to? With functions you can do that, and all the knowledge you’d need is how to make the barplot look the way you want. This works shop gives a quick overview of how to use functions to make your life easier. Demonstrations will be done in R, but are applicable to most languages.

One of the more powerful aspects of programming languages relative GUI statistical softwares is the ability to create functions. Functions are extremely powerful because they allow for the automation of repetitive tasks and reduce bloated code from the more traditional “copy-paste” format. This becomes extremely powerful when combined with the apply family or loops. However, even for simple tasks, functions can make your life easier.

Why use functions?

save complicated operations or mathematical calculations
reduce repetitive tasks
standardize formats (e.g. plots, maps, etc)
combine with apply family for automation of tasks



### Install packages 
```{r eval=FALSE}
install.packages("here")
```

### Load libraries & data
##### Quick aside on the genius of the <code>here</code> package:
Whether they're collaborating with colleagues, uploading to data repositories after submitting a paper, or uploading scripts to Github for anyone to use, people who write code constantly share their code. **A great time-saving strategy for streamlining code-sharing is to use <code>here</code>**, a package intended to facilitate file referencing by getting rid of absolute filepaths (which makes your code fragile and difficult to integrate into other people's systems) and instead using relative filepaths (which makes your code easier to transfer to other people's systems). [See Jenny Bryan's overview of the package](https://github.com/jennybc/here_here) for more information and convincing arguments for adopting <code>here</code>.

Load libraries
```{r message=FALSE}
library(here) # Look where your folder begins.
```

Make two dataframes from built-in dataset, "Body Temperature Series of Two Beavers"
```{r}
beaver_1 <- beaver1
beaver_2 <- beaver2
```

***
### Functions: The Basics
***
#### What is a function?

A function is a command that executes one to several tasks all at once. You've probably used functions before. In R, for example, we frequently use functions that have been made by other people: <code>read.csv()</code> and <code>print()</code> are functions, to name a few.

**Function Syntax**
The format of function is fairly simple:

`functionName <- function(arguments){ arguments + operation }`

#### When should we make our own functions?

In a 2016 [interview with Naturally Speaking](https://naturallyspeaking.blog/2016/06/22/episode-41-conversations-with-an-r-jedi/), Hadley Wickham explains,

> "A really good rule of thumb is, as soon as you've copied and pasted something more than twice, it's time to start thinking, 'how can I get rid of that duplication?'"

So if you think it wise to take the advice of RStudio's widely regarded Chief Scientist (which I certainly do!), then you should consider making your own functions when you find yourself copying and pasting something **3 or more times.**

There will always be times to break this rule, but here's Hadley again on why it's important to learn how to write your own functions:

> "Any time you've got duplication in your code, there's just a chance for... bugs to come in because... you change one, and you forget to change another one, you get inconsistencies. It's really frustrating."

***
### Exercises
***
#### Goal 1: Make a function that exports a dataframe to csv

**How to set up a function**

When you set up a function, the first two things you want to think about are 1) what you will name your function and 2) the variables the function will need in order to produce an output.

In the function below, the name is <code>add_numbers</code> and the input variables are called <code>number_1</code>, <code>number_2</code>, and <code>number_3</code>. Big surprise: it adds three numbers together!

After adding your function name and variables as in the format below (you can have lots of input variables, more than the three we're using), add a set of curly brackets. Inside the curly brackets ({}), write the chunk of code that you want your function to execute (the body). The body should reference your input variables. It should also be indented, which R will automatically do once you press "Enter" after typing the curly brackets.

```{r}
add_numbers <- function(number_1, number_2, number_3) {
  number_1 + number_2 + number_3
}
```

```{r}
add_numbers(1,10,100)
```

Take a look at how we've applied the same structuring logic to set up this function as well. This function is performing the <code>write.csv()</code> function on an object referenced as "dataframe". It will export the object to a file referenced as "filename".

I've explicitly told R that the write.csv function should use its "x" argument on what I've called "dataframe", and "file" on "filename".
```{r}
Beaver_to_csv1.1 <- function(dataframe, filename) {
  write.csv(x = dataframe,
            file = filename)
}
```

#### Example 1: Export beaver csv with only filename in path
**Create object that we'll use as our filename**

Notice we've added the file type (extension) to the filename: .csv
```{r}
filename1.1 <- "Beaver1.csv" 
```

**Use function to export dataframe object to csv**
```{r}
Beaver_to_csv1.1(beaver_1,
                 filename1.1)
```




#### Example 2: Export beaver csv with only filename in path

**Make a folder especially for beaver file exports**

Find where your project folder begins (its root):
```{r eval=FALSE}
here::here()
```

Then manually create a new folder in that directory called "exports".

**Create new input variables for new function**
Make new path:
```{r}
path1.2 <- here::here("./exports/ ") 
```
*I'm not sure how to export without a space in the filepath, so I'm adding a space to the right side of the last /. We'll get rid of it later.*

Make new file name and file type. This time we'll separate the file name from the file type so that we can change up the file type by indicating it as an input variable.
```{r}
filename1.2 <- "Beaver1"
filetype1.2 <- ".csv"
```

**Make function that exports dataframe object to csv in csvs folder**
To accommodate the file path and file type objects, we'll add a two more input variables to our new function's set of input variables.
```{r}
Beaver_to_csv1.2 <- function(dataframe, path, filename, filetype) {
  write.csv(dataframe,
            gsub(" ", "",
                 paste0(path,
                        filename,
                        filetype)))
}
```

Here's what the function is doing:

1. First, look to the most indented portion of the code, which starts with <code>paste0</code>. The <code>paste0()</code> function is taking three input variables and pasting them together: path, filename, and filetype.
2. Next, look to the function encompassing that code: the <code>gsub()</code> function. This function is finding any spaces and *substituting* them with nothing (essentially removing any spaces it finds, particularly the space we had to put in the path).
3. Finally, the outermost shell is the <code>write.csv()</code> function, which is taking our dataframe as the object to be exported, and will name and export this object where the conglomerate path + filename + filetype tells it to.


#### Try out the function with a few examples

Export dataframe to csv in csvs folder:
```{r}
Beaver_to_csv1.2(beaver_1, path1.2, filename1.2, filetype1.2)
```

Just for fun, add .txt as a file type option:
```{r}
Beaver_to_csv1.2(beaver_1, path1.2, filename1.2, ".txt")
```

We could skip the step of saving the function's input variables to individual objects and just input it all on the fly, as shown here:
```{r}
Beaver_to_csv1.2(dataframe = beaver_1,
                 path = here::here("./exports/ "),
                 filename = "Beaver1",
                 filetype = ".txt")
```

You don't need the "x =" portion either but feel free to keep it if it helps you clarify your code.
```{r}
Beaver_to_csv1.2(beaver_1,
                 here::here("./exports/ "),
                 "Beaver1",
                 ".csv")
```


***

## Goal 2: Make a function that exports a list of dataframes to separate csvs
### Make list of beaver dataframes
```{r}
Beavers <- list(beaver_1, beaver_2)
```

### Create function
```{r}
Export_beaver_list <- function(df_list, path, filetype) {
  for (i in 1:length(df_list)){
    Beaver_to_csv1.2(df_list[i], path, paste0("Beaver", i), filetype)
  }
}
```

### Run function
```{r}
Export_beaver_list(Beavers, 
                   here::here("./exports/ "),
                   ".csv")
```

***

## Goal 3: Make, export plots for multiple dataframes
### Create a function that uses a dataframe as input, then exports a plot
#### Create a regular plot
```{r}
plot(beaver_1$temp ~ beaver_1$time,
     xlim = c(0, 2400),
     ylim = c(36, 38),
     xlab = "Time of Day",
     ylab = "Beaver Temperature (C)",
     col = "dark green",
     pch = 2,
     cex = .5)
```

#### Make the plot more easily reproducible
One way to do so is to name relative (vs. absolute) axis limits. This plot will begin its x axis, which is plotting time, 0.5 units before the datapoint with the lowest time value. It will extend the x axis 0.5 units after the datapoint with the highest time unit. The same is true for the y axis' limits for temperature.
```{r}
plot(temp ~ time,
     data = beaver_1,
     xlim = c(min(time),
              max(time)),
     ylim = c(min(temp) - 0.5,
              max(temp) + 0.5),
     xlab = "Time of Day",
     ylab = "Beaver Temperature (C)",
     col = "dark green",
     pch = 2, # point shape
     cex = .5) # point size
```

#### Create function
```{r}
Beaver_to_plot <- function(dataframe, path, filename, filetype) {
  
  png(file = gsub(" ", "",
                 paste0(path, filename, filetype)))
  
  plot(temp ~ time,
       data = dataframe,
       xlim = c(min(time),
                max(time)),
       ylim = c(min(temp) - 0.5,
                max(temp) + 0.5),
       xlab = "Time of Day",
       ylab = "Beaver Temperature (C)",
       col = "dark green",
       pch = 2, # point shape
       cex = .5) # point size
  
  dev.off() # tells R to stop plotting
  
}
```

#### Run function
```{r}
Beaver_to_plot(beaver_1,
               here::here("./exports/ "),
               "Beaver1.1",
               ".png")
```

### Scale up: Create a function that uses a list of dataframes as input, then exports multiple plots
#### Create function
```{r}
Beaver_to_plot_many <- function(df_list, path, filetype) {
  for (i in 1:length(df_list)){
    Beaver_to_plot(df_list[[i]],
                   path,
                   paste0("Beaver", i, "_plot2"),
                   filetype)
  }
}
```

#### Run function
```{r}
Beaver_to_plot_many(Beavers,
                    here::here("./exports/ "),
                    ".png")
```

***

# Extra credit
## Ellipsis
You don't always need to specify all of the input variables for a function. Sometimes you can make use of a tool called an **ellipsis**. An ellipsis is, you guessed it, three dots in a row: "...".

The most straightforward usage of an ellipsis is for when you want to make your function flexible enough to handle an unspecified number of input variables. For instance, think about the <code>paste()</code> function.

The <code>paste()</code> function can print any number of input variables:
```{r}
paste("This", "phrase", "has", "five", "variables")
paste("How", "about", "three?")
paste("I", "could", "go", "on", "and", "on", "and", "on", "and", "on", "and", "on...")
```

### Example function with an ellipsis
#### Create function
```{r}
ellipsis_example <- function(x_var, y_var, ...){
  plot(y_var ~ x_var,
       ...)
}
```

#### Run function
```{r}
ellipsis_example(x_var = beaver_1$time,
                 y_var = beaver_1$temp,
                 pch = beaver_1$activ,
                 col = "magenta",
                 main = "One Beaver's Daily Temperature",
                 sub = "circles = beaver engaged in high-intensity activity",
                 xlab = "Time of Day",
                 ylab = "Temperature (C)")
```

## Extra exercises
For those interested, [here are some additional exercises](https://discdown.org/rprogramming/functions.html) crafted by Reto Stauffer, Joanna Chimiak-Opoka, Luis Miguel Rodríguez-R, Thorsten Simon, and Achim Zeileis from their resource, *"Introduction to Programming with R"*.